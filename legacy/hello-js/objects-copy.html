<!DOCTYPE html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="styles/pages.css">
	<link rel="stylesheet" type="text/css" href="https://necolas.github.io/normalize.css/8.0.1/normalize.css">
	<title>Копирование объектов и ссылки</title>
</head>
<body>
	<a class="homeB" href="http://r90625ip.beget.tech/"><img class="homeButton" src="img/home.png" height="100px"><img class="homeButtonWhite" src="img/homeHover.png" height="100px"></a>
	<a class="homeB" href="index-hello-js.html">Назад</a>

	<ul>
		<li>
			<h2>Как хранятся объекты</h2>
			<p>
				Объект, в отличие от примитивных типов данных, хранится и копируются "по ссылке", а не "по значению". Переменная в данном случае хранит <b>не сам объект, а его адрес в памяти,</b> иначе говоря, ссылку на него. <br>
				При копировании переменной объекта, копируется ссылка, но сам объект при этом не дублируется. <br>
			</p>
			<h2>Сравнение по ссылке</h2>
			<p>
				Два объекта будут равны только в том случае, если это один и тот же объект. Другими словами, при сравнении двух переменных, они будут равны только тогда, когда они ссылаются на один и тот же объект. <br>
			</p>
			<h2>Клонирование и объединение объектов, Object.assign</h2>
			<p>
				Для создания полной копии (клона) объекта существует несколько вариантов. Первый - это копирование с помощью цикла.
				<code>
					let user = { <br>
						name: "Ivan", <br>
						age: 23, <br>
					}; <br>

					let clone = {}; <br>

					//копирование всех свойств user в пустой объект clone <br>
					for (let key in user) { <br>
						clone[key] = user[key]; <br>
					}; <br>
				</code>
				Второй вариант - это использование метода Object.assign. <br>
				<code>
					Object.assign(dest, [src1, src2, ... , srcN]); <br>
				</code>
				Здесь первый аргумент dest - это целевой объект, в который производится копирование. <br>
				Остальные аргументы [src1, src2, ... , srcN] - это исходные объекты, свойства которых копируются в целевой объект dest. <br>
				Возвращает данных метод новый объект dest. <br>
				Данный метод, помимо копирования, позволяет объединить несколько объектов в один. <br>
				<code>
					let user = { <br>
						name: "Ivan", <br>
						age: 23, <br>
					}; <br>

					let clone = Object.assign({}, user); //обычное клонирование объекта<br>

					let permission1 = { canView: true, }; <br>
					let permission2 = { canEdit: true, }; <br>

					Object.assign(user, permission1, permission2); //объединение, копирование свойств из permission1 и permission2 в объект user<br>
				</code>
			</p>
			<h2>Вложенное клонирование</h2>
			<p>
				В случае, если клонируемый объект содержит в себе другой объект, то обычное клонирование, которое рассматривалось до этого, будет копировать вложенный объект уже по ссылке, и при изменении в одном объекте, изменения произойдут и в другом. Для того, чтобы это избежать, существует два варианта. <br>
				Первый - это делать проверку на то, является ли клонироемое значение объектом, в цикле клонирования. Это называется глубокое клонирование. <br>
				Второй - это делать глубокое клонирвоание, используя рекурсию. В данном случае можно поступить проще и воспользоваться методом _.cloneDeep(obj) из библиотеки <a href="https://lodash.com/">lodash</a>. <br>
			</p>
		</li>
	</ul>
</body>
</html>